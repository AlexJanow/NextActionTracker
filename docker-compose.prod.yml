# Production configuration for docker-compose
# Usage: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

services:
  db:
    environment:
      POSTGRES_DB: nat_prod
      POSTGRES_USER: ${DB_USER:-nat_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      # Performance tuning
      POSTGRES_SHARED_BUFFERS: 256MB
      POSTGRES_EFFECTIVE_CACHE_SIZE: 1GB
      POSTGRES_MAINTENANCE_WORK_MEM: 64MB
      POSTGRES_CHECKPOINT_COMPLETION_TARGET: 0.9
      POSTGRES_WAL_BUFFERS: 16MB
      POSTGRES_DEFAULT_STATISTICS_TARGET: 100
    volumes:
      - postgres_prod_data:/var/lib/postgresql/data
      - ./database/postgresql.conf:/etc/postgresql/postgresql.conf:ro
    ports: []  # Don't expose database port in production
    command: ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M

  backend:
    environment:
      DATABASE_URL: postgresql://${DB_USER:-nat_user}:${DB_PASSWORD}@db:5432/nat_prod
      ENVIRONMENT: production
      DEBUG: false
      LOG_LEVEL: info
      PYTHONPATH: /app
      # Performance settings
      WORKERS: ${BACKEND_WORKERS:-4}
      MAX_CONNECTIONS: 100
      KEEPALIVE: 2
    volumes: []  # No source code mounting in production
    command: [
      "uvicorn", "app.main:app", 
      "--host", "0.0.0.0", 
      "--port", "8000", 
      "--workers", "${BACKEND_WORKERS:-4}",
      "--worker-class", "uvicorn.workers.UvicornWorker",
      "--max-requests", "1000",
      "--max-requests-jitter", "100",
      "--preload"
    ]
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
    environment:
      NODE_ENV: production
      REACT_APP_API_URL: ${API_URL:-/api}
      REACT_APP_TENANT_ID: ${TENANT_ID}
    volumes: []  # No source code mounting in production
    deploy:
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # Optional: Add a reverse proxy for production
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - frontend
      - backend
    deploy:
      resources:
        limits:
          memory: 64M
        reservations:
          memory: 32M

volumes:
  postgres_prod_data:
    driver: local